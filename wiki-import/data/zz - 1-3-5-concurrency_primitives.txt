1.3.5. Concurrency Primitives
    1.3.5.1. Iteration & Data Flow  
        1.3.5.1.1 Iterator  
        1.3.5.1.2 Generator  
        1.3.5.1.3 Stream  
        1.3.5.1.4 Zipper  
        1.3.5.1.5 Observable / Reactive Stream  
    1.3.5.2. Control Flow  
        1.3.5.2.1 Thread  
        1.3.5.2.2 Process  
        1.3.5.2.3 Fiber / Green Thread  
        1.3.5.2.4 Promise / Future  
        1.3.5.2.5 Task / Async Function  
        1.3.5.2.6 Coroutine  
        1.3.5.2.7 Callback  
        1.3.5.2.8 Event / Event Emitter  
        1.3.5.2.9 Continuation / Trampoline  
    1.3.5.3. Message Passing & Data Exchange  
        1.3.5.3.1 Channel  
        1.3.5.3.2 Actor  
        1.3.5.3.3 Tuple Space  
        1.3.5.3.4 Rendezvous (CSP‑style exchange)  
    1.3.5.4. Synchronization Primitives  
        1.3.5.4.1 Lock (Mutex)  
            1.3.5.4.1.1 Reader/Writer Lock  
            1.3.5.4.1.2 Spinlock  
        1.3.5.4.2 Semaphore  
        1.3.5.4.3 Barrier  
        1.3.5.4.4 Latch / CountDownLatch  
        1.3.5.4.5 Condition Variable  
        1.3.5.4.6 Atomic Object (Compare‑and‑Swap)  
        1.3.5.4.7 Read‑Copy‑Update (RCU)  
        1.3.5.4.8 Monitor / Critical Section  
        1.3.5.4.9 Phaser / CyclicBarrier  
    1.3.5.5. Coordination & Multiplexing  
        1.3.5.5.1 I/O Multiplexing  
            1.3.5.5.1.1 Select  
            1.3.5.5.1.2 Poll  
            1.3.5.5.1.3 Waitset  
            1.3.5.5.1.4 epoll / kqueue / IOCP  
        1.3.5.5.2 Scheduler (Fiber / Green‑thread scheduler)  
            1.3.5.5.2.1 Work‑Stealing Deque  
            1.3.5.5.2.2 Thread Pool / Worker Pool  
        1.3.5.5.3 Reactor / Proactor (Event Loop)  
    1.3.5.6. Memory Models & Transactions  
        1.3.5.6.1 Memory Fence / Barrier  
        1.3.5.6.2 Transactional Memory  